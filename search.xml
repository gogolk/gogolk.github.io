<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[项目：Python开发自动预约实验软件Gettem]]></title>
    <url>%2F2018%2F07%2F03%2FGettem1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;为解决学校电镜实验预约困难影响科研进展，我通过python开发了一个可自动预约电镜实验的程序。以下为详细介绍，总体可分为5各部分：&emsp;&emsp;1. 项目背景。&emsp;&emsp;2. 工具准备。&emsp;&emsp;3. requests模拟登录。&emsp;&emsp;4. requests模拟发送请求。&emsp;&emsp;5. 优化程序功能，自动化设置时间，并且图形化软件。&emsp;&emsp;6. 转换成exe文件，便于操作与分享。 项目背景&emsp;&emsp;透射电镜可以算是每个高校学术研究的稀缺资源，尤其在材料领域大多数研究都离不开透射电镜。本校的电镜可预约时间为每周一到周五，上午8:30-11:30和下午14:30-15:30共十个时间段.而每个时间段开放预约时间为前一周该时间段结束时间前后。这种狼多肉少的情况使得大家预约电镜非常困难，甚至有时候课题组两周都约不到一次，科研进展受到影响。所以，这个项目完成后可以很好的解决以上问题。 工具准备Fiddler:一款开源的网络抓包工具,简单来说使fidder成为一个客户端与服务器的中间代理，客户端发送request将先发送给fidder，fidder再转发送给服务器，服务器返回的response则先到达fidder再返回客户端。 Requests:一个Python第三方HTTP库，功能全面几乎可以实现任何的http请求任务, 包括GET、OPTIONS、HEAD、POST、PUT、PATCH、DELETE。在这些request中，可根据需要的更改header，body，cookie，data等，操作方便。此外，特别值得一提的是它包含一个会话对象requests.Session()，可以跨请求保持某些参数，例如cookie，不用手动添加cookie. 在对同一个服务器连续的发出请求时，底层的TCP将被复用，就不用每发一个请求重新发送TCP连接请求，使性能显著提高。 Tkinter:一个Python的标准GUI库。使用Tkinter可以快速的创建GUI应用程序。操作简单，可以满足大多数图形化需求。 requests模拟登录&emsp;&emsp;浏览器打开网站，正常登录。通过fidder抓包。可以发现有以下request&emsp;&emsp;可以发现登录发送表单所需数据为userName，password和enter.除此之外，我们还可以发现服务器返回的是302，重定向。继续跟踪可发现还需向目标网址发送一个表单&emsp;&emsp;表单需要的数据可以发现在重定向后发送请求中的response中。&emsp;&emsp;综上，操作顺序为：发送请求（账号，密码）→在获得的重定向response中抓取信息→再发送请求→登录成功，编写代码如下123456789101112131415161718192021222324252627282930313233import request#定义会话se = request.Session()def login(userName, passWord): ''' 登录 ''' res = se.get(loginurl, timeout=15) if res.status_code == 200: form_data = &#123; "userName": userName, "passWord": passWord, "enter": True &#125; res = se.post(self.loginurl, form_data) #正则抓取toke_id token_id = search(compile('&lt;input name="tokenId" type="hidden" value="(.*?)"'), res.content.decode('utf-8')).group(1) form_data_2 = &#123; "tokenId": token_id, "account": userName, "Thirdsys": "dxsbgxxt" &#125; login_url = 'http:/xxxxxx.com' #跟进header，测试后其实不改也没关系。这里只是为了模拟浏览器更像一点。 se.update(&#123;'Referer': 'http://xxxxxx.com'&#125;) se.post(login_url, form_data_2) se.session.cookies.set('ASP.NET_SessionId',None) return#测试一下if __main__ == '__name__': userName = input('输入账号’) passWord = input('输入密码') login(userName, passWord)&emsp;&emsp;测试完成登录成功，接下来实现模拟浏览器发送表单 requests模拟发送请求&emsp;&emsp;首先分析出表单所需要的数据，通过浏览器预约一个是简单的实验。同样通过fidder抓包分析，在此过程中，我们可以通过断点来判断一共发送了哪些请求，哪些求中是必须的，哪些请求又是可以省去的，因为毕竟我们需要快速预约，所以要把过程做的最精简。通过断点测试我们发现有如下请求发送出去&emsp;&emsp;一共7个request…其中有4个post,分析这些post所需数据,分析数据来源,处理成所需数据格式，最终代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147class OrderTEM(object): ''' 物镜球差电镜预约 ''' def __init__(self, user, pwd, payload, id_, st, et, sample, project, i): ''' 定义会话，初始化表单。 params &#123; user:用户名 pwd: 密码 payload, id_为申请表单所需数据，不同用户数据不同，在注册过程中记录。 st: 预约时间段开始时间 et: 预约时间段结束时间 sample: 样品 project: 项目编号 i: 控制多线程可以均匀发表的编号，i越高，发送请求的开始时间越晚 &#125; ''' self.user = user self.pwd = pwd self.payload = payload self.id = id_ self.st = st self.et = et self.i = i self.session = requests.session() self.update = self.session.headers.update self.get = self.session.get self.post = self.session.post self.loginurl = (r'http://xxxxxx.com') self.headers1 = &#123;'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language':'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2', 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Upgrade-Insecure-Requests':'1', &#125; self.headers2 = &#123;'Referer': None&#125; self.session.headers.update(self.headers1) #初始化申请实验表单 self.form_data_1 = &#123; "_ajax": 1, "_object": "component_form", "_event": "submit", "cal_week_rel": '', "mode": "week", "component_id": 0, "calendar_id": 7, "name123": "仪器使用预约", "dtstart": self.st, "dtend": self.et, "project": project, "description": '', "extra_fields[12]": sample, "extra_fields[13][块体]": 'null', 'extra_fields[13][粉末]': 'on', 'extra_fields[13][有无磁性]': 'null', 'extra_fields[14][TEM]': 'on', 'extra_fields[14][HRTEM]': 'on', 'extra_fields[14][STEM]': 'null', 'extra_fields[14][STEM+mapping]': 'null', 'extra_fields[14][EDS]': 'null', 'submit': 'save' &#125; self.form_data_2 = &#123;'_ajax': 1, '_object': 'socket', '_event': 'auth', 'cal_week_rel': '', 'code' : '' &#125; def login(self): ''' 登录 ''' res = self.get(self.loginurl, timeout=15) if res.status_code == 200: form_data = &#123; "userName": self.user, "passWord": self.pwd, "enter": True &#125; res = self.post(self.loginurl, form_data) self.logincookies = self.session.cookies.get_dict() token_id = search(compile('&lt;input name="tokenId" type="hidden" value="(.*?)"'), res.content.decode('utf-8')).group(1) form_data_3 = &#123; "tokenId": token_id, "account": self.user, "Thirdsys": "dxsbgxxt" &#125; login_url = 'http://xxxxxx.com' self.update(&#123;'Referer': 'http://xxxxx.com'&#125;) self.post(login_url, form_data_3) self.session.cookies.set('ASP.NET_SessionId',None) return True else: raise '网络异常！' def perpareform(self): ''' 爬取目标页面并解析表单所需的数据 ''' url = 'http://xxxxx.com' #??self.session.headers.update(self.headers2) res1 = self.get(url) self.update(&#123;'Referer': 'http://xxxxx.com', 'Upgrade-Insecure-Requests': None&#125;) content_1 = res1.content.decode('utf-8') partern_1 = compile('"browser_[^"]+?" src="(http://xxxxx\?browser_id=(.+?)&amp;amp;st=(.+?)&amp;amp;ed=(.+?)&amp;amp;.+?form_token(.+?))"') content_1 = search(partern_1, content_1) post_url = content_1.group(1) browser_id = content_1.group(2) st2 = content_1.group(3) ed = content_1.group(4) form_token = content_1.group(5) post_url = sub(compile('amp;'),'',post_url) res2 = self.get(post_url) content_2 = res2.content.decode('utf-8') #id="calweek_5b25321017f43" partern_2 = compile('id="(calweek_.+?)"') cal_week_rel = search(partern_2,content_2).group(1) self.form_data_1['cal_week_rel' ] = cal_week_rel return post_url, browser_id, st2, ed, form_token, cal_week_rel def postform(self,post_url, browser_id, st2, ed, form_token, cal_week_rel): ''' 利用爬取到的数据填写表单并提交申请。 ''' res3 = self.post(post_url,self.form_data_1) self.update(&#123;'Accept': '*/*'&#125;) content_3 = res3.content.decode('utf-8') #\" id=\"uuid_5b253c614b5cd\"&gt;\ uuid = search(compile(r'(uuid_.+?)\\'),content_3).group(1) #params = &#123;'EIO': 3, 'transport': 'polling', 't': str(int(datetime.now().timestamp * 10*3)) + '-0'&#125; res4 = self.session.get('http://xxxxxx.com',params=&#123;'EIO': '3', 'transport': 'polling', 't': str(int(datetime.now().timestamp()*(10**3)))+'-0'&#125;) content_4 = res4.content sid = search(compile('"sid":"(.+?)"'),str(content_4)).group(1) self.session.get('http://xxxxxx/socket.io/',params=&#123;'EIO': '3', 'transport': 'polling', 't': str(int(datetime.now().timestamp()*(10**3)))+'-1','sid': sid&#125;) self.update(&#123;'Origin': 'http://xxxxxx.com','Content-Type': 'text/plain;charset=UTF-8'&#125;) self.post('http://xxxxxx/socket.io/',params=&#123;'EIO': '3', 'transport': 'polling', 't': str(int(datetime.now().timestamp()*(10**3)))+'-2','sid': sid&#125;,data = self.payload) self.update(&#123;'Origin': None, 'Content-Type': None&#125;) res7 = self.get('http://xxxxxx/socket.io/',params=&#123;'EIO': '3', 'transport': 'polling', 't': str(int(datetime.now().timestamp()*(10**3)))+'-3','sid': sid&#125;) content_7 = str(res7.content) code = search(compile('"code":"(.+?)"'),content_7).group(1) self.form_data_2['code'] = code res8 = self.post('http://xxxxxx.com',data = self.form_data_2) content_8 =str(res8.content) newcode = search(compile('"code":"(.+?)"'),content_8).group(1) newcode = sub(r'\\','',newcode) self.update(&#123;'Content-Type':'text/plain;charset=UTF-8'&#125;) payload2 = r'1048:42["yiqikong-reserv",&#123;"form":"&#123;\"cal_week_rel\":\"%s\",\"mode\":\"week\",\"component_id\":\"0\",\"calendar_id\":\"7\",\"name\":\"\\u4eea\\u5668\\u4f7f\\u7528\\u9884\\u7ea6\",\"dtstart\":%d,\"dtend\":%d,\"project\":\"1074\",\"description\":\"\",\"extra_fields\":&#123;\"12\":\"\",\"13\":&#123;\"\\u5757\\u4f53\":\"on\",\"\\u7c89\\u672b\":\"null\",\"\\u6709\\u65e0\\u78c1\\u6027\":\"null\"&#125;,\"14\":&#123;\"TEM\":\"on\",\"HRTEM\":\"on\",\"STEM\":\"null\",\"STEM+mapping\":\"null\",\"EDS\":\"null\"&#125;&#125;,\"submit\":\"save\",\"browser_id\":\"%s\",\"st\":\"%s\",\"ed\":\"%s\",\"equipment_id\":\"10\",\"form_token\":\"%s\",\"id\":\"7\",\"currentUserId\":\"%s\",\"SITE_ID\":\"cf\",\"LAB_ID\":\"xxx\",\"tube\":\"8fcab38c0b49b43aaf3d13888fe9444066f3940d\",\"uuid\":\"%s\"&#125;","code":"%s"&#125;]' %(cal_week_rel, self.st, self.et, browser_id, st2, ed, form_token, self.id, uuid, newcode) self.post('http://xxxxxx/socket.io/',params=&#123;'EIO': '3', 'transport': 'polling', 't': str(int(datetime.now().timestamp()*(10**3)))+'-5','sid': sid&#125;,data = payload2) self.update(&#123;'Content-Type': None&#125;) &emsp;&emsp;最开始没有设置i, 而是直接让10个线程不间断的发送请求，但是测试后发现预约成功率并不高， 分析得知该程序设计为同步发送，所以每次发送请求后必须要等到请求返回才发下一次的请求，而开放预约时间前后因用户请求暴增导致服务器返回请求缓慢，有时候达到了2s以上，这样会导致在预约时间开放之前我发送的表单还没返回的时候开放预约，而此各个线程要等到返回才发送请求，导致预约失败。于是改进程序，通过self.et - datetime.now().timestamp() - 604800 - 20 + self.i * 0.25 &lt; 0 BEGIN POST为每个线程设置发送表单的开始时间,间隔为0.25s循环发送申请。并通过记录开始发送请求到最后返回请求的时间，让线程sleep (max(2.5 - end + start,0))，使各个线程均匀的没2.5s发送一个请求，总体上实现均匀0.25s发送一个请求，调度程序代码如下1234567891011121314151617181920212223def main_1(self): ''' 调度程序； 登录&gt; 抓取必要元素并填写表单 &gt; 提交表单 ''' self.login() sleep(10) post_url, browser_id, st2, ed, form_token, cal_week_rel = self.perpareform() while 1: while self.et - datetime.now().timestamp() - 604800 - 20 + self.i * 0.25 &lt; 0: while 1: try: start = datetime.now().timestamp() self.postform(post_url, browser_id, st2, ed, form_token, cal_week_rel) if self.et - datetime.now().timestamp() - 604800 + 10 &lt; 0: break end = datetime.now().timestamp() sleep (max(2.5 - end + start,0)) except: pass break if self.et - datetime.now().timestamp() - 604800 + 10 &lt; 0: break 优化程序功能; 自动计算预约时间；注册功能；图形化设计自动计算预约时间&emsp;&emsp;因为预约开放时间是固定的，所以每次欲预约的实验时间是可以预算的，即下周上午或者下午，若在11:30之前，预约时间为下周8:30-11:30，超过11:30直到下午5:30，即预约下周下午时间段。所以可以设置一个默认时间，而自定义时间是因为有些同学经过培训可以预约中午或者晚上。添加一个getst模块。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class getst(object): def __init__(self, opt, equipment = None, ymd = None, date2 = None ): ''' opt:用户选择自定义时间还是默认, equipment:选择设备，因为设备不同中午时间有所 ymd, date2: 用户自定义选择的时间。 ''' self.opt = opt self.ymd = ymd self.date2 = date2 self.equipment = equipment def default(self): ''' 默认时间，根据当前时间计算出最近即将开放的时间段。 ''' today = datetime.now() t = (today.hour,today.minute) if t &lt; (11,31): st = datetime(today.year, today.month, today.day, 8, 30, 0 ).timestamp() + 604800 elif t &lt; (17,31): st = datetime(today.year, today.month, today.day, 14, 30, 0 ).timestamp() + 604800 else: st = datetime(today.year, today.month, today.day, 8, 30, 0 ).timestamp() + 691200 return int(st) def userdefined(self, ymd, date2, equipment): ''' 自定义预约时间 ''' #ymd is dict,&#123;'year':year,....&#125; if date2 == '早': st = int(datetime(ymd['year'], ymd['month'], ymd['day'], 8, 30, 0).timestamp()) elif date2 == '下午': st = int(datetime(ymd['year'], ymd['month'], ymd['day'], 14, 30, 0).timestamp()) elif date2 == '晚上': st = int(datetime(ymd['year'], ymd['month'], ymd['day'], 19, 0, 0).timestamp()) else: if equipment == '1': st = int(datetime(ymd['year'], ymd['month'], ymd['day'], 12, 0, 0).timestamp()) else: st = int(datetime(ymd['year'], ymd['month'], ymd['day'], 11, 45, 0).timestamp()) return int(st) def getst(self): ''' return: start time 根据用户选择默认或自定义 默认则为下一次可预约时间 自定义则约抢任意时间，包括针对管理员的中午时间段和晚上时间段。 ''' if self.opt == 'userdefind': return self.userdefined(self.ymd, self.date2, self.equipment) else: return self.default() 多个实验预约整合在一起; 多线程&emsp;&emsp; 以上已经完成了模拟登录，模拟发送表单，自动获得预约时间，下面将整合输入，整合所有实验模块，并实现多线程。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667def gettem(name, equipment, sample, project, time, log_, date = None, date2 = None): ''' name: 用户名 equipment: 目标设备 sample: 样品名 project: 项目号码 time: 时间选择(默认，自定义) log_: 日志 date: 自定义日期 date2: 自定义时间段 ''' #------------------------------------------------------------------------# if time =='userdefind': st = getst('userdefind', equipment, date, date2).getst() if date2 != '中': et = st + 10799 else: et = st + 8999 else: st = getst('default').getst() et = st + 10799 if equipment == 1: log_.insert('end','准备预约：球差\n' ) else: log_.insert('end','准备预约：场发射\n' ) log_.insert('end','%s\n' % (datetime.fromtimestamp(st).strftime('%a %Y-%m-%d %H:%M:%S'))) log_.insert('end','%s\n' % (datetime.fromtimestamp(et).strftime(' %Y-%m-%d %H:%M:%S'))) while 1: c = datetime.now().timestamp() #设置子线程开始登录时间为 -40s if et - 604800 - 40 &lt; c: with open('users.txt','r') as f: userdicts = json.loads(f.read()) userdict = userdicts[name] if equipment == 1: userdict = userdicts['%s' % name] log_.insert('end','开始登录...\n') for i in range(10): a = OrderTEM_1(userdict['username'],userdict['pwd'], userdict['payload'], userdict['id'], st, et, sample, project, i) p = Thread(target = a.main_1) p.daemon = True p.start() sleep(15) log_.insert('end','开始交表...\n') elif equipment == 2: userdict = userdicts['%s' % name] log_.insert('end','开始登录...、\n') for j in range(10): b = OrderTEM_2(userdict['username'],userdict['pwd'], userdict['payload'], userdict['id'], st, et, sample, project, j) q = Thread(target = b.main_2) q.daemon = True q.start() sleep(15) log_.insert('end','开始交表...\n') sleep(35) checkit = check(userdict['username'], userdict['pwd'] , st, et , name, equipment) checkit.login_check() form_data = checkit.perpareform_check() dict_ = checkit.checking(form_data) content = dict_['content'] name = search(checkit.username, content) if name: log_.insert('end','预约成功') else: log_.insert('end','预约失败') break sleep(10)&emsp;&emsp;这里面有个多出来的check模块，它的功能是可以检测本次预约是否成功并返回结果，是根据本次目标时间爬取网站上该时间段预约人的名字与用户名对比判断的，比较简单，就不赘述了。 图形化设计&emsp;&emsp;为了方便程序，图形化软件。整合输入参数，除账号之外，预约实验需要添加的信息有时间选择(自定义|默认)，实验选择，样品，项目编号等。通过python自带的Tkinter库简易实现图形化，编写代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200def gui(): ''' Getten图形化 ''' def run(): ''' 开始运行 ''' tem = vartem.get() time = vartime.get() name = ename.get().strip() account = eaccont.get() sample = esample.get() date = edate.get().strip() date2 = comdate2.get() project = comproject.get() if tem and time and name and account and sample and project: if time == 'userdefind': if len(date) == 8: date = &#123;'year':int(date[:4]),'month':int(date[4:6]),'day':int(date[6:8])&#125; else: tk.messagebox.showerror('错误', '自定义时间有误?') with open('users.txt', 'r') as f: userdicts = json.loads(f.read()) if name in userdicts: if account != userdicts[name]['username']: tk.messagebox.showerror('错误','用户名与账号不匹配') else: th = Thread(target = gettem, args=(name, tem, sample, project, time, log_, date, date2)) th.daemon = True th.start() runbutton.config(state = 'disabled') ename.config(state = 'disabled') eaccont.config(state = 'disabled') esample.config(state = 'disabled') edate.config(state = 'disabled') comdate2.config(state = 'disabled') comproject.config(state = 'disabled') rtem1.config(state = 'disabled') rtem2.config(state = 'disabled') rtime1.config(state = 'disabled') rtime2.config(state = 'disabled') signbutton.config(state = 'disabled') else: t = tk.messagebox.askokcancel('注册','你还没注册,请先注册吧') if t == True: sign() else: tk.messagebox.showerror('错误','有信息未填，请检查。') def quit(): ''' 关闭 ''' os._exit(0) def datef(): edate.config(state = 'disable') comdate2.config(state = 'disable') def datef2(): edate.config(state = 'normal') comdate2.config(state = 'readonly') window = tk.Tk() window.title('Gettem') window.geometry('200x500+600+150') window.resizable(width = False, height = False) window.protocol("WM_DELETE_WINDOW", quit) #框架，图片 mainframe = tk.Frame(window, bg = 'White') mainframe.pack(fill = 'both', expand = 1) #labels linfo = tk.Label(mainframe, text = '使用方法\n1.注册，将姓名及账号进行登记。\n2.注册完成后,选择时间。\n (默认为下次开放时间)\n\3.填写信息，点击开始。\n (至少提前30s开始)\n4.保持网络，不关机。\n5.组内同学使用,切勿外传。', justify = 'left', bg = 'White', wraplength = 240,font = ('黑体',8)) ltem = tk.Label(text='TEM：',font=('黑体',10), fg = 'DeepSkyBlue', bg = 'White') ltime = tk.Label(text = '时间：',font=('黑体',10), fg = 'DeepSkyBlue', bg = 'White') lname = tk.Label(text = '名字：', font=('黑体',10), fg = 'DeepSkyBlue', bg = 'White') laccont = tk.Label(text = '账号：', font=('黑体',10), fg = 'DeepSkyBlue', bg = 'White') lsample = tk.Label(text = '样品：', font=('黑体',10), fg = 'DeepSkyBlue', bg = 'White') ldate = tk.Label(text = '日期：', font=('黑体',10), fg = 'DeepSkyBlue', bg = 'White') lparoject = tk.Label(text = '项目：', font=('黑体',10), fg = 'DeepSkyBlue', bg = 'White') linfo.place(x = 6, y = 2) ltem.place(x = 8, y = 110) ltime.place(x = 8, y = 145) lname.place(x = 8, y = 180) laccont.place(x = 8, y = 215) lsample.place(x = 8, y = 250) ldate.place(x = 8, y = 285) lparoject.place(x = 8, y = 320) #选择按钮 vartem = tk.IntVar() vartime = tk.StringVar() vartem.set(1) vartime.set('default') rtem1 = tk.Radiobutton(text = '球差', bg = 'White', variable = vartem, value = 1) rtem2 = tk.Radiobutton(text = '场发射', bg = 'White', variable = vartem, value = 2) rtime1 = tk.Radiobutton(text = '默认', bg = 'White', variable = vartime, value = 'default', command = datef) rtime2 = tk.Radiobutton(text = '自定义', bg = 'White', variable = vartime, value = 'userdefind', command = datef2) rtem1.place(x = 60, y = 107) rtem2.place(x = 115, y = 107) rtime1.place(x = 60, y = 142) rtime2.place(x = 115, y = 142) vardate = tk.StringVar() vardate.set((datetime.now() + timedelta(days=7)).strftime('%Y%m%d')) #输入entry ename = tk.Entry(bg = 'Lightyellow', width = 15, font = ('黑体',11), highlightcolor = 'DeepSkyBlue', justify = 'center',highlightthickness = 1) eaccont = tk.Entry(bg = 'Lightyellow', width = 15, font = ('黑体',11), highlightcolor = 'DeepSkyBlue', justify = 'center',highlightthickness = 1) esample = tk.Entry(bg = 'Lightyellow', width = 15, font = ('黑体',11), highlightcolor = 'DeepSkyBlue', justify = 'center',highlightthickness = 1) edate = tk.Entry(bg = 'Lightyellow', width = 12, font = ('黑体',8), highlightcolor = 'DeepSkyBlue', justify = 'center',highlightthickness = 1, textvariable = vardate, state = 'disable') ename.place(x = 60, y = 180, heigh = 25) eaccont.place(x = 60, y = 215, heigh = 25) esample.place(x = 60, y = 250, heigh = 25) edate.place(x = 60, y = 285, heigh = 25) #下拉菜单：project 和 早中晚 vardate2 = StringVar() comdate2 = ttk.Combobox(mainframe, width = 4, justify = 'center', font = ('宋体',8), textvariable = vardate2, state = 'disable') comdate2['value'] = ('早', '中', '下午', '晚上') comdate2.place(x = 140, y = 286, heigh = 23) comdate2.current(1) varproject = IntVar() comproject = ttk.Combobox(mainframe, width = 17, justify = 'center', font = ('宋体',8), textvariable = varproject) comproject['value'] = (1074, 1084, 1180) comproject.place(x = 60, y = 319, heigh = 23) comproject.current(0) #buttons runbutton = tk.Button(width = 8, height = 1, text = '开始', font = ('黑体', 11), bg = 'Aliceblue', fg = 'DeepSkyBlue', relief = 'ridge', bd = 2, cursor = 'target', command = run) signbutton = tk.Button(text = '注册', font = ('黑体', 9), bg = 'White', fg = 'Red', bd = 0, cursor = 'target', command = sign) runbutton.place(x = 60, y = 350) signbutton.place(x = 150, y = 360) log_ = scrolledtext.ScrolledText(width = 250, height = 10, font = ('宋体', 10, ' bold'), relief = 'sunken', bg = 'Lightyellow', wrap=tk.WORD) log_.place(y = 390) window.mainloop()def sign(): ''' 账号注册 ''' def user_sign_check(event): sign_user_pwd = enew_pwd.get() sign_user_name = enew_username.get() sign_user_account = enew_account.get() if not (sign_user_pwd and sign_user_name and sign_user_account): tk.messagebox.showerror('错误', '请完整填写信息') else: try: with open('users.txt', 'r') as f: userdicts = json.loads(f.read()) except FileNotFoundError: with open('users.txt', 'w') as f: userdicts = &#123;'name': &#123;&#125;&#125; t = json.dumps(userdicts) f.write(t) if sign_user_name in userdicts: tk.messagebox.showerror('错误', '你已经注册过了...') else: st = getst('default').default() et = st + 10799 #b = OrderTEM_2(userdict['username'],userdict['pwd'], userdict['payload'], userdict['id'], st, et, sample, project, j) check_ = OrderTEM_1(sign_user_account, sign_user_pwd, '', '', st, et,'hf' , 1000, 0) t = check_.login_sign() if t == -2: tk.messagebox.showerror('错误','网络异常，请检查') elif t == -1: tk.messagebox.showerror('错误', '账号不存在或密码错误') else: id_ = t post_url, browser_id, st2, ed, form_token, cal_week_rel = check_.perpareform_1() payload = check_.get_payload(post_url, browser_id, st2, ed, form_token, cal_week_rel) userdicts[sign_user_name] = &#123;'username':sign_user_account, 'pwd':sign_user_pwd, 'payload':payload, 'id':id_&#125; with open('users.txt', 'w') as f: t = json.dumps(userdicts) f.write(t) tk.messagebox.showinfo('OK', '注册成功！') win_sign.destroy() win_sign = tk.Toplevel() win_sign.title('注册') win_sign.geometry('250x200+650+300') mainframe = tk.Frame(win_sign, bg = 'White') mainframe.pack(fill='both' ,expand=1) lname = tk.Label(win_sign,text='*姓名：',font=('黑体',10), fg = 'DeepSkyBlue', bg = 'White') laccount = tk.Label(win_sign, text = '*账号：',font=('黑体',10), fg = 'DeepSkyBlue', bg = 'White') lpwd = tk.Label(win_sign, text = '*密码：', font=('黑体',10), fg = 'DeepSkyBlue', bg = 'White') lname.place(x = 10, y = 20) laccount.place(x = 10, y = 60) lpwd.place(x = 10, y = 100) enew_username = tk.Entry(win_sign, bg = 'Lightyellow', width = 20, font = ('黑体',11), highlightcolor = 'DeepSkyBlue', justify = 'center',highlightthickness = 1) enew_account = tk.Entry(win_sign, bg = 'Lightyellow', width = 20, font = ('黑体',11), highlightcolor = 'DeepSkyBlue', justify = 'center',highlightthickness = 1) enew_pwd = tk.Entry(win_sign, bg = 'Lightyellow', width = 20, font = ('黑体',11), highlightcolor = 'DeepSkyBlue', justify = 'center',highlightthickness = 1,show = '*') enew_username.place(x = 60, y = 20, heigh = 25) enew_account.place(x = 60, y = 60, heigh = 25) enew_pwd.place(x = 60, y = 100, heigh = 25) signbutton = tk.Button(win_sign, text='注册',font=('黑体',14), fg = 'DeepSkyBlue', bg = 'White', relief = 'ridge', bd = 0, command = (lambda : user_sign_check(1))) signbutton.place(x = 100, y = 140) enew_username.bind("&lt;Return&gt;", user_sign_check) enew_pwd.bind("&lt;Return&gt;", user_sign_check) enew_account.bind("&lt;Return&gt;", user_sign_check)&emsp;&emsp;考虑到程序安全性，可以先把交给课题组某个同学负责，然后其他同学都可以让负责的同学帮忙预约实验，而添加注册功能就可以同学第一次先注册后，以后则不用告诉负责同学密码，只需输入姓名和账户名即可，这样不仅保护了同学密码，也保护了软件。&emsp;&emsp;主要界面&emsp;&emsp;注册界面&emsp;&emsp;开始运行 转换成exe文件，便于操作与分享。&emsp;&emsp;通过pyInstaller将py转换成exe，需要安装pywin32库。在命令行中输入python pyinstaller.py -F Gettem.py。 总结&emsp;&emsp;好了，基本工作就到此就基本完成了。接下来就是测试这个程序好不好使，至少到目前为止，共预约5次，每次都成功预约，成功率达到100%。如果以后要改进程序的话，可以从以下几个方面考虑： 增加线程数，经测试，增加线程可以一定程度上提高提交频率，但有上限值，因为网络瓶颈。 将同步改成异步，使得每次发送请求后不用等到返回，在一定时间内继续发送，这样不仅可以提高提交频率并且可以使发送请求的时间间隔更加均匀。但这将要大刀阔斧更改程序，还需要把多线程改为多进程，需要一定工作量。 将多线程转换成多进程，因为python的GIL锁缘故，多线程并不是真正意义上的多线程，只是并发了，那为什么这里要设置多线程呢，因为在一个线程发送请求时还没返回时这是一个I/O操作，这个等待的时间就会让其他线程去发送请求了，所以还是可以提高发送请求速度。但CPU还是只用一个CPU，而如果用多进程的话，就可以更大利用资源，不过Gettem需要CPU资源实在很少，所以多进程的作用不太理想。]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F17%2Fpython%2F</url>
    <content type="text"><![CDATA[Hello World！]]></content>
  </entry>
</search>
